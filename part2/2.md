인덱스 기본 사용법
---

+ 인덱스 기본 사용법은 인덱스를 Range Scan 하는 방법을 의미한다.
+ 인덱스를 Range Scan 할 수 없게 되는 이유를 알고 나면, 인덱스를 Range Scan 하는 방법도 자연스럽게 터득한다.

인덱스를 사용한다는 것
===

+ 색인이 정렬돼있더라도 가공한 값이나 중간값으로는 스캔 시작점을 찾을 수 없다.
+ 색인을 아예 사용 할 수 없는 것은 아니다. 시작점을 찾을 수 없고 멈출 수 없을 뿐이다.
+ 가공한 값이나 중간값을 찾을 때도 색인을 사용할 수 있지만, 색인 전체를 스캔해야한다. 

인덱스를 Range Scan 할 수 없는 이유
===

+ 인덱스 스캔 시작점을 찾을 수 없기 때문
+ 일정 범위를 스캔하려면 시작지점과 끝지점이 존재해야한다.

더 중요한 인덱스 사용 조건
===

+ 인덱스를 Range Scan 하기 위한 가장 첫 번째 조건은 인덱스 선두 컬럼이 조건절에 있어야 한다는 사실이다. 가공하지 않은 상태로
+ 인덱스를 Range Scan 하려면 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있어야 한다.

인덱스를 이용한 소트 연산 생략
===

+ 인덱스를 Range Scan 할 수 있는 이유가 데이터가 정렬돼 있기 때문이다.
+ 옵티마이저는 SQL에 ORDER BY가 있어도 정렬 연산을 따로 수행하지 않는다.
+ SORT ORDER BY 연산이 없음을 확인해야 한다.
+ 정렬 연산을 생략할 수 있게 인덱스가 구성돼 있지 않다면, SORT ORDER BY 연산 단계가 추가된다.

ORDER BY 절에서 컬럼 가공
===

+


SELECT-LIST에서 컬럼 가공
===

+ 인덱스 리프 블록의 왼쪽 또는 오른쪽에서 레코드 하나만 읽고 멈춘다.
+ 장비당 이력 레코드가 많다면 복잡한 SQL보다 성능이 더 안좋을 수 있다.


자동 형변환
===

+ 타입 체크를 엄격히 함으로써 컴파일 시점에 에러를 내는 DBMS가 있는가 하면, 자동으로 형변환 처리해주는 DBMS도 있다.
+ 오라클에서는 숫자형과 문자형이 만나면 숫자형이 이긴다.
+ 날짜형과 문자형이 만나면 날짜형이 이긴다.
+ 숫자형과 문자형이 만나면 숫자형이 이긴다고 했지만, 연산자가 LIKE일때는 다르다.
+ 자동 형변환에 의존하지 말고 인덱스 컬럼 기준으로 반대편 컬럼 또는 값을 정확하게 형변환해 주어야 한다.
