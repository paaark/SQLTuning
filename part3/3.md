인덱스 스캔 효율화
===

+ 인덱스 탐색

```
수직적 탐색은 스캔 시작점을 찾는 과정이다.
수평적 탐색은 수직적 탐색없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식이다.
```

+ 인덱스 스캔 효율성

```
인덱스 선행 컬럼이 조건절에 없거나 '=' 조건이 아니면 인덱스 스캔 과정에 비효율이 발생한다.
```

+ 액세스 조건과 필터 조건

## 액세스 조건

1. 인덱스 스캔 범위를 결정하는 조건절
2. 인덱스 수직적 탐색을 통해 스캔 시작점을 결정하는데 영향을 미치고
3. 인덱스 리프 블록을 스캔하다가 어디서 멈출지를 결정하는 데 영향을 미치는 조건절이다.

## 필터 조건

1. 인덱스를 이용하든
2. 테이블을 Full Scan 하든
3. 테이블 액세스 단계에서 처리되는 조건절은 모두 필터조건이며
4. 테이블 필터 조건은 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지를 결정한다.

+ 비교 연산자 종류와 컬럼 순서에 다른 군집성

```
1. 테이블과 달리 인덱스에는 '같은 값'을 갖는 레코드들이 서로 군집해 있다.
2. '같은 값'을 찾을 때 '=' 연산자를 사용하므로 인덱스 컬럼을 앞쪽부터 누락없이 '=' 연산자로 조회하면 조건절을 만족하는 레코드는 모두 모여있다.
3. 어느 하나를 누락하거나 '=' 조건이 아닌 연산자로 조회하면 조건절을 만족하는 레코드가 서로 흩어진 상태가 된다.
```

+ 인덱스 선행 컬럼이 등치(=) 조건이 아닐때 생기는 비효율

1. 인덱스 스캔 효율성은 인덱스 컬럼을 조건절에 모두 등치(=) 조건으로 사용할 때 가장 좋다.
2. 인덱스 선행 컬럼이 조건절에 없거나 부등호, BETWEEN, LIKE 같은 범위검색 조건이면 인덱스를 스캔하는 단계에서 비효율이 생긴다.


+ BETWEEN을 IN-LIST로 전환

1. 범위검색 컬럼이 맨 뒤로 가도록 인덱스를 BETWEEN 조건을 IN-List로 바꿔주면 큰 효과를 얻는 경우가 있다.
2. IN-List 개수 만큼 UNION ALL 브랜치가 생성되고 각 브랜치마다 모든 컬럼을 '=' 조건으로 검색하므로 앞서 선두 컬럼에 BETWEEN을 사용할 때와 같은 비효율이 사라진다.


+ Index Skip Scan 활용

1. 테이블을 전혀 방문하지 않았는데도 I/O가 많이 발생하는 이유는 인덱스 선두 컬럼이 BETWEEN 조건이어서 만족하는 레코드까지 모두 스캔하고 버렸기 때문이다.
2. 선두 컬럼이 BETWEEN이어서 나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨어져있을 때 Index Skip Scan의 위력이 나타난다.


+ IN 조건은 '='인가

1. IN 조건은 '='이 아니다.
2. IN 조건이 '='이 되려면 IN-List Iterator 방식으로 풀려야만 한다.
3. IN 조건은 필터 조건이다.

+ BETWEEN과 LIKE 스캔 범위 비교

1. BETWEEN과 LIKE는 둘 다 범위검색 조건으로서, 앞에서 설명한 범위검색 조건을 사용할 때의 비효율 원리가 똑같이 적용된다.
2. 하지만 데이터 분포와 조건절 값에 따라 인덱스 스캔량이 서로 다를 수 있다.
3. LIKE보다 BETWEEN을 사용하는 게 낫다.

+ 범위검색 조건을 남용할 때 생기는 비효율

1. 코딩을 쉽게 하려고 인덱스 컬럼에 범위검색 조건을 남용하면 인덱스 스캔 비효율이 생긴다.
2. 인덱스 스캔 비효율이 성능에 미치는 여향이 적을 수도 있지만, 대량 테이블을 넓은 범위로 검색할 때는 그 형향이 매우 클 수도있다.
3. SQL 작성할 때 주의해야 하며, 데이터 분포에 따라 인덱스 컬럼에 대한 비교 연산자를 신중하게 선택해야 한다.

+ 다양한 옵션 조건 처리 방식의 장단점 비교

## OR 조건 활용

1. 인덱스 액세스 조건으로 사용 불가
2. 인덱스 필터 조건으로도 사용 불가
3. 테이블 필터 조건으로만 사용 가능
4. 단, 인덱스 구성 컬럼 중 하나 이상이 Not Null 컬럼이면, 18c부터 인덱스 필터 조건으로 사용 가능

## LKIE/BETWEEN 조건 활용

1. 인덱스 선두 컬럼
2. NULL 허용 컬럼
3. 숫자형 컬럼
4. 가변 길이 컬럼

## UNION ALL 활용

1. 옵션 조건 컬럼도 인덱스 액세스 조건으로 사용한다는 사실이 매우 중요하다.
2. NULL 허용 컬럼이더라도 사용하는 데 전혀 문제가 없다.
3. 유일한 단점으로 SQL 코딩량이 길어진다.

## NVL/DECODE 함수 활용

1. 가장 큰 장점은 옵션 조건 컬럼을 인덱스 액세스 조건으로 사용할 수 있다.
2. UNION ALL 보다 단순하면서도 UNION ALL과 같은 성능을 낸다.
3. 단점으로는 NULL을 입력하면 값이 NULL인 레코드가 결과집합에서 누락되기 때문이다.

+ 함수호출부하 해소를 위한 익덱스 구성

## PL/SQL 함수의 성능적 특성

```
PL/SQL 사용자 정의 함수는 개발자들이 일반적으로 생각하는 것보다 매우 느리다.
```

## PL/SQL 사용자 정의 함수가 느린 3가지 이유

1. 가상머신상에는 실행되는 인터프리터 언어
2. 호출 시마다 컨텍스트 스위칭 발생
3. 내장 SQL에 대한 Recursive Call 발생
