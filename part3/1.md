테이블 액세스 최소화
---

+ 테이블 랜덤 액세스

```
아무리 데이터가 많아도 인덱스를 사용하니까 데이터가 금방 조회된다.
대량 데이터를 조회할 때 인덱스를 사용하니 테이블 전체를 스캔할 때보다 훨씬 느리다.
```

+ 인덱스 ROWID는 물리적 주소? 논리적 주소?

```
인덱스를 스캔하는 이유는 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고 거기서 테이블 레코드를 찾아가기 위한 주소값, 즉 ROWID를 얻으려는 데 있다.
ROWID는 물리적 주소보다 논리적 주소에 가깝다.
테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있기 때문이다.
```

+ 메인 메모리 DB와 비교

```
메인 메모리 DB의 경우 인스턴스를 기동하면 디스크에 저장된 데이터를 버퍼캐시로 로딩하고 이어서 인덱스를 생성한다.
인덱스는 디스크 상의 주소정보를 갖는 게 아니라 메모리상의 주소정보, 즉 포인터를 얻는다.
메모리 주소 정보가 아닌 디스크 주소 정보를 이용해 해시 알고리즘으로 버퍼 블록을 찾아간다.
일반 DBMS에서 인덱스 ROWID를 이용한 테이블 액세스가 생각만큼 빠르지 않다.
```

+ I/O 매커니즘 복습

```
DBA는 디스크 상에서 블록을 찾기 위한 주소 정보다.
I/O 성능을 높이려면 버퍼캐시를 활용해야 한다.
그래서 블록을 읽을 때는 디스크로 가기전에 버퍼캐시부터 찾아본다.
읽고자 하는 DBA를 해시 함수에 입력해서 해시 체인을 찾고 거기서 버퍼 헤더를 찾는다.
인덱스로 테이블 블록을 액세스할 때는 리프 블록에서 읽은 ROWID를 분해해서 DBA 정보를 얻고 테이블을 Full Scan 할 때는 익스텐트 맵을 통해 읽을 블록들의 DBA 정보를 얻는다.
```

+ 인덱스 클러스터링 팩터

```
클러스터링 펙터는 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다.
클러스터링 펙터가 안 좋은 인덱스를 사용하면 테이블을 액세스하는 횟수만큼 고스란히 블록 I/O가 발생한다.
```

+ 인덱스 손익분기점

```
인덱스 ROWID를 이용한 테이블 액세스는 생각보다 고비용 구조다.
읽어야 할 데이터가 일정량을 넘는 순간, 테이블 전체를 스캔하는 것보다 오히려 느려진다.
Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점을 흔히 인덱스 손익 분기점이라고 부른다.
Table Full Scna은 성능이 일정하다.
```

+ 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝

```
온라인 프로그램은 보통 소량 데이터를 읽고 갱신하므로 인덱스를 효과적으로 활용하는 것이 무엇보다 중요하다.
조인도 대부분 NL 방식을 사용한다.
NL 조인은 인덱스를 이용하는 조인 방식이다.
```

```
대량 데이터를 읽고 갱신하는 배치 프로그램은 항상 전체 범위 처리 기준으로 튜닝해야 한다.
처리 대상 집합 중 일부를 빠르게 처리하는 것이 아니라 전체를 빠르게 처리하는 것을 목표로 삼아야 한다.
대량 데이터를 빠르게 처리하려면 인덱스와 NL 조인보다 Full Scan과 해시 조인이 유리하다.
```

+ 인덱스 컬럼 추가

```
테이블 액세스 최소화를 위해 가장 일반적으로 사용하는 튜닝 기법은 인덱스에 컬럼을 추가하는 것이다.
```

+ 인덱스만 읽고 처리

```
쿼리에 단일 컬럼으로 구성된 인덱스를 사용한다면, 비효율은 없다.
인덱스에서 LIKE 조건에 해당하는 데이터를 찾고 테이블을 액세스한 후에 버리는 데이터가 하나도 없기 때문이다.
비효율이 없더라도 인덱스 스캔 과정에서 얻은 데이터가 많다면 그만큼 테이블 랜덤 액세스가 많이 발생하므로 성능이 느릴 수 밖에 없다.
쿼리에 사용된 컬럼을 모두 인덱스에 추가해서 테이블 액세스가 아예 발생하지 않게 하는 방법을 고려해 볼 수 있다.
인덱스만 읽어서 처리하는 쿼리를 Covered 쿼리라고 부르며, 그 쿼리에 사용한 인덱스를 Covered 인덱스라고 부른다.
```

+ Include 인덱스

```
인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능이다.
인덱스를 생성할 때 아래와 같이 include 옵션을 지정하면 된다.
include 인덱스는 순전히 테이블 랜덤 액세스를 줄이는 용도로 개발됐다.
```

```SQL
create index emp_x01 on emp (deptno) include (sal)
```

+ 인덱스 구조 테이블

```
테이블을 찾아가기 위한 ROWID를 갖는 일반 인덱스와 달리 IOT는 그자리에 테이블 데이터를 갖는다.
즉, 테이블 블록에 있어야 할 데이터를 인덱스 리프 블록에 모두 저장하고 있다.
IOT에서는 인덱스 리프 블록이 곧 데이터 블록이다.
```

```
일반 힙 구조 테이블에 데이터를 입력할 때는 랜덤 방식을 사용한다.
Freelist로 부터 할당 받은 블록에 정해진 순서 없이 데이터를 입력한다.
반면 IOT는 인덱스 구조 테이블이므로 정렬 상태를 유지하며 데이터를 입력한다.
```

+ 클러스터 테이블

```
클러스터 테이블에는 인덱스 클러스터와 해시 클러스터 두 가지가 있다.
```

인덱스 클러스터 테이블
===

```
인덱스 클러스터 테이블은 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조다.
한 블록에 모두 담을 수 없을 때는 새로운 블록을 할당해서 클러스터 체인으로 연결한다.
여러 테이블 레코드를 같은 블록에 저장할 수도 있는데 이를 다중 테이블 클러스터라고 부른다.
```

```
클러스터 인덱스도 일반 BTree 인덱스 구조를 사용하지만, 테이블 레코드를 일일이 가리키지 않고 해당 키 값을 저장하는 첫 번째 데이터 블록을 가리킨다는 점이 다르다.
일반 테이블에 생성한 인덱스 레코드는 테이블 레코드와 1:1 대응 관계를 갖지만, 클러스터 인덱스는 테이블 레코드와 1:M 관계를 갖는다.
따라서 클러스터 인덱스의 키 값은 항상 Unique하다.(중복값이 없다.)
```

해시 클러스터 테이블
===

```
해시 클러스터는 인덱스를 사용하지 않고 해시 알고리즘을 사용해 클러스터를 찾아간다는 점만 다르다.
```
